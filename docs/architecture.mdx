---
title: "Architecture"
description: "Composable skills architecture for building complex behaviours from simpler ones."
---

# Composable Skills Architecture

This document defines the **composability extension** to the Agent Skills format, enabling atomic skills to be combined into higher-order workflows - like higher-order functions in functional programming.

## The Problem: Non-Deterministic Tool Selection in Multi-Team Environments

As organisations rapidly develop MCP servers and agent skills, a critical problem emerges that threatens the reliability of AI agent systems.

### Why Flat Skills Fail at Scale

When multiple developers create skills independently - particularly across different teams or MCP servers - they inevitably build overlapping functionality with subtly different implementations. Without a formal composition hierarchy, these skills violate **MECE principles** (Mutually Exclusive, Collectively Exhaustive):

| Problem | Consequence |
|---------|-------------|
| **Overlapping skills** | Multiple skills can handle the same request, but with different approaches and assumptions |
| **Non-deterministic selection** | LLMs may choose different tools for identical prompts across runs |
| **Cascading inconsistency** | A skill chosen on Monday may not be chosen on Tuesday, even for the same task |
| **Unpredictable permutations** | With N overlapping skills, there are N! possible execution paths the agent might take |

**The result:** Agent systems that appear to "have a mind of their own" - executing tasks differently each time, making them unsuitable for applications requiring real-world reliability.

### What Trustworthy Agents Require

Production-grade agent systems must be:

- **Predictable**: The same input should produce the same tool selection
- **Deterministic**: Execution paths should be reproducible and auditable
- **Reliable**: Behaviour that worked yesterday should work identically tomorrow
- **Trustworthy**: Users must be confident the agent will "just do the right thing"

Flat skill definitions cannot guarantee these properties because they provide no mechanism for:
- Defining canonical implementations of common operations
- Expressing skill dependencies and composition relationships
- Ensuring teams build on shared primitives rather than duplicating logic
- Preventing overlapping skill definitions that confuse tool selection

### The Fast-Moving Team Problem

This problem is particularly acute in fast-moving organisations where:
- Multiple teams develop MCP servers in parallel
- Skills are added rapidly without cross-team coordination
- Different developers have different assumptions about how tasks should be performed
- There is no single source of truth for "how we do X"

The lack of composition primitives means teams cannot formally declare "our `research` skill uses the canonical `web-search` skill" - instead, each team builds their own search implementation, creating the overlap that causes non-determinism.

### The Context Window Problem

Compounding these challenges is a fundamental constraint: **LLMs have finite context windows, yet we are experiencing an explosion of available tools**.

When an agent must reason about dozens of flat, potentially overlapping skills:

| Challenge | Impact |
|-----------|--------|
| **Context saturation** | Tool definitions consume budget that could be used for actual reasoning |
| **Ambiguous selection** | Similar descriptions force the LLM to make arbitrary choices |
| **Combinatorial complexity** | Reasoning difficulty grows exponentially with tool count |
| **Inconsistent mental models** | The LLM cannot form clear abstractions when tools overlap |

Composable skills provide an elegant solution: **small, contained, unambiguous primitives** that the LLM can reason about clearly. Instead of choosing between 50 overlapping tools with subtle differences, the agent selects from a curated set of atomic operations with single responsibilities.

The composition layer then handles orchestration deterministically - no LLM reasoning required for "which sub-tool should I use?" because the `composes` field has already declared the answer.

## The Solution: Composable Skills

Composable skills introduce a **hierarchical architecture** that enforces MECE principles through explicit composition:

```
Level 3: Workflows        Complex multi-step processes with decision logic
    ↑ composes
Level 2: Composites       Combined operations for common patterns
    ↑ composes
Level 1: Atomics          Single-purpose operations (READ or WRITE)
    ↑ wraps
Level 0: Primitives       Raw scripts, APIs, or tools
```

### How Composition Solves Non-Determinism

| Principle | Implementation |
|-----------|----------------|
| **Single responsibility** | Level 1 atomics do ONE thing - no overlap possible |
| **Explicit dependencies** | `composes` field declares exactly which skills are used |
| **Canonical paths** | Higher-level skills compose lower-level ones, not alternatives |
| **Auditable structure** | Dependency graph is visible, verifiable, and enforceable |

When a team declares that `research` composes `web-search` + `pdf-save`, there is no ambiguity about which tools will be invoked. The LLM selects `research`, and the composition is deterministic.

### Visual: Composition Graph

The following diagram shows how a Level 3 workflow composes Level 2 composites, which in turn compose Level 1 atomics:

```
                         ┌─────────────────────────────────────┐
                         │         daily-briefing              │
                         │            (Level 3)                │
                         │         operation: READ             │
                         └──────────────┬──────────────────────┘
                                        │
              ┌─────────────┬───────────┼───────────┬─────────────┐
              │             │           │           │             │
              ▼             ▼           ▼           ▼             ▼
        ┌──────────┐  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐
        │ calendar │  │  email   │ │ research │ │ customer │ │  slack   │
        │  -read   │  │  -read   │ │ (Lvl 2)  │ │  -intel  │ │  -read   │
        │ (Lvl 1)  │  │ (Lvl 1)  │ │          │ │ (Lvl 2)  │ │ (Lvl 1)  │
        └──────────┘  └──────────┘ └────┬─────┘ └────┬─────┘ └──────────┘
                                        │            │
                                   ┌────┴────┐  ┌────┴────────┐
                                   │         │  │      │      │
                                   ▼         ▼  ▼      ▼      ▼
                              ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐
                              │  web   │ │  pdf   │ │hubspot │ │  email │
                              │-search │ │ -save  │ │ -read  │ │ -read  │
                              │(Lvl 1) │ │(Lvl 1) │ │(Lvl 1) │ │(Lvl 1) │
                              └────────┘ └────────┘ └────────┘ └────────┘

Legend:
  Level 3 = Workflow (orchestration + decision logic)
  Level 2 = Composite (combines atomics)
  Level 1 = Atomic (single operation)
```

**Key insight:** The LLM only needs to decide "use daily-briefing" - all downstream composition is deterministic.

### Benefits of This Architecture

| Benefit | Description |
|---------|-------------|
| **Predictability** | Composition graph determines execution path - no surprises |
| **Determinism** | Same skill selection yields same tool invocations every time |
| **Simpler LLM reasoning** | Small, unambiguous atomics are easier to reason about than many overlapping tools |
| **Context efficiency** | Fewer tool definitions in context; composition replaces enumeration |
| **Team coordination** | Shared atomics prevent duplicate implementations across teams |
| **Reusability** | Write atomic skills once, compose everywhere |
| **Testability** | Each level can be tested independently; failures are isolated |
| **Safety** | Clear READ/WRITE separation at every level; safety propagates upward |
| **Discoverability** | Structured hierarchy is easy to navigate and understand |
| **Maintainability** | Changes isolated to appropriate level; update once, benefit everywhere |
| **Extensibility** | New skills slot into existing levels without restructuring |
| **Transparency** | `composes` field makes dependencies explicit and auditable |

### The Functional Programming Analogy

Think of composable skills like higher-order functions:

```python
# Level 1: Atomic functions
def read_email(query): ...
def search_web(query): ...
def save_pdf(url, path): ...

# Level 2: Composite function
def research(topic):
    results = search_web(topic)
    for url in results.citations:
        save_pdf(url, f"sources/{url.slug}.pdf")
    return results

# Level 3: Workflow function
def daily_synthesis():
    emails = read_email("flagged:true")
    for item in classify(emails):
        if item.needs_research:
            research(item.topic)
        create_task(item)
```

The same principles apply to skills:
- **Pure functions** → Atomic skills with single responsibility
- **Function composition** → Composite skills combining atomics
- **Pipelines** → Workflow skills orchestrating composites

---

## Skill Levels

### How to Determine the Correct Level

Use this decision flowchart to classify a skill:

```
Does the skill wrap a primitive directly without calling other skills?
│
├── YES → Level 1 (Atomic)
│
└── NO → Does the skill contain ANY of these?
          • Self-recursion (skill composes itself)
          • Loops (for each item, repeat until condition)
          • Dynamic skill selection at runtime
          • Parallel fan-out / fan-in orchestration
          • State management across invocations
          │
          ├── YES → Level 3 (Workflow)
          │
          └── NO → Level 2 (Composite)
```

### Level Criteria Summary

| Criterion | Level 1 (Atomic) | Level 2 (Composite) | Level 3 (Workflow) |
|-----------|------------------|---------------------|-------------------|
| **Composition** | None (wraps primitives only) | Composes L1 or L2 skills | Composes any level (L1, L2, or L3) |
| **Control flow** | Linear, no branching | Simple conditionals | Loops, recursion, dynamic dispatch |
| **Execution** | Single invocation | Sequential or simple parallel | Complex orchestration patterns |
| **State** | Stateless | Stateless | May maintain state across invocations |
| **Decision logic** | None | "If X, also do Y" | "For each X, decide which skill to invoke" |

### Level 0: Primitives

The foundation layer. Primitives are **not skills themselves** - they're the raw scripts, APIs, or tools that skills wrap.

**Examples:**
- Python scripts (`extract_pdf.py`)
- Shell commands (`git`, `curl`)
- API endpoints (Gmail API, Slack API)
- MCP tools

Primitives have no `SKILL.md`. Skills at Level 1 wrap them.

### Level 1: Atomic Skills

Single-purpose operations. Each atomic skill does **ONE thing** and classifies as either READ or WRITE.

**Characteristics:**
- Does exactly one operation
- Has clear inputs and outputs
- Either READ-only (safe) or WRITE (requires confirmation)
- Wraps one or more primitives

**Example frontmatter:**
```yaml
---
name: email-read
description: Search and fetch emails from Gmail or Outlook. Use when user needs to find or read emails.
level: 1
operation: READ
---
```

**Common atomic skills:**

| Skill | Operation | Purpose |
|-------|-----------|---------|
| `email-read` | READ | Search/fetch emails |
| `email-draft` | WRITE | Create email drafts |
| `web-search` | READ | Search the web |
| `pdf-save` | WRITE | Save URL as PDF |
| `calendar-read` | READ | Query calendar events |
| `calendar-write` | WRITE | Create/modify events |

### Level 2: Composite Skills

Combined operations that orchestrate multiple atomic skills into cohesive workflows.

**Characteristics:**
- Composes 2+ atomic skills
- Has a clear, single purpose
- May include transformation logic
- Safety level = most restrictive of components

**Example frontmatter:**
```yaml
---
name: research
description: Research a topic with web search and source verification. Use for comprehensive topic research.
level: 2
operation: READ  # All composed skills are READ-only
composes:
  - web-search
  - web-fetch
---
```

**Common composite skills:**

| Skill | Composes | Purpose |
|-------|----------|---------|
| `research` | web-search + web-fetch | Topic research with sources |
| `evidence-collector` | web-fetch + pdf-save | Archive web pages as PDFs |
| `customer-intel` | hubspot-read + slack-read + email-read | Aggregate customer data |
| `meeting-capture` | transcript-read + note-write | Meeting notes from transcripts |

### Level 3: Workflow Skills

Complex orchestration with control flow that goes beyond simple sequential composition.

**A skill is Level 3 if it contains ANY of these patterns:**

| Pattern | Description | Example |
|---------|-------------|---------|
| **Self-recursion** | Skill composes itself | `deep-research` follows citation chains recursively |
| **Loops** | Iterates over a collection | `daily-briefing` processes each meeting |
| **Dynamic dispatch** | Chooses skills at runtime | Skip customer-intel for internal meetings |
| **Fan-out/fan-in** | Parallel execution with aggregation | Research multiple topics concurrently |
| **Cross-invocation state** | Maintains context between calls | Track progress across a multi-day workflow |

**Characteristics:**
- May compose any level (L1, L2, or other L3 workflows)
- Contains decision points, loops, or recursion
- Often produces multiple outputs or side effects
- May run over extended time periods

**Example frontmatter:**
```yaml
---
name: daily-synthesis
description: Extract and track action items from all communication channels. Run daily for task tracking.
level: 3
operation: WRITE  # Creates issues/tasks
composes:
  - email-read
  - slack-read
  - transcript-read
  - linear-write
---
```

### Level 3 Composing Level 3 (Workflow Orchestration)

A Level 3 workflow may compose other Level 3 workflows. This enables **workflow orchestration** - treating complex workflows as reusable units.

**Example: Quarterly Review orchestrating Daily Briefings**

```yaml
---
name: quarterly-review
description: Generate quarterly review by aggregating daily briefings and synthesising trends.
level: 3
operation: READ
composes:
  - daily-briefing      # L3 workflow - run for each day in quarter
  - monthly-summary     # L3 workflow - run for each month
  - research            # L2 composite - for trend analysis
---
```

**When to use L3 → L3 composition:**
- The sub-workflow is a complete, meaningful unit of work
- You need to run the same workflow multiple times (loop)
- The sub-workflow has its own decision logic that should be encapsulated

**When NOT to use L3 → L3:**
- If you're just combining capabilities, use L2 → L2 instead
- If the "sub-workflow" has no loops/recursion/decisions, it's probably L2

---

## New Frontmatter Fields

The composability extension adds these optional fields to the SKILL.md frontmatter:

### `level` (optional)

Integer 1-3 indicating the skill's tier in the composition hierarchy.

| Value | Meaning |
|-------|---------|
| `1` | Atomic - single operation |
| `2` | Composite - combines atomics |
| `3` | Workflow - complex orchestration |

If omitted, the skill is treated as a standalone (traditional) skill.

### `operation` (optional)

The safety classification of the skill.

| Value | Meaning | Confirmation |
|-------|---------|--------------|
| `READ` | Only reads data, no side effects | Never required |
| `WRITE` | Creates, modifies, or deletes data | Recommended |
| `TRANSFORM` | Local-only transformation | Never required |

For composite skills, operation should be the **most restrictive** of its components:
- If any component is WRITE → skill is WRITE
- If all components are READ → skill is READ

### `composes` (optional)

List of skill names this skill uses. Creates an explicit dependency graph.

```yaml
composes:
  - email-read
  - slack-read
  - hubspot-read
```

**Benefits of explicit composition:**
- **Auditable**: See exactly what a skill does
- **Testable**: Verify all dependencies are available
- **Upgradeable**: Know what's affected when changing a skill

### `primitives` (optional, Level 1 only)

For atomic skills, lists the underlying scripts or tools wrapped:

```yaml
primitives:
  gmail: scripts/gmail/search_emails.py
  outlook: scripts/outlook/get_emails.py
```

---

## Example: Building a Research Workflow

### Step 1: Atomic Skills (Level 1)

**web-search/SKILL.md:**
```yaml
---
name: web-search
description: Search the web using Perplexity AI. Returns synthesised answers with citations.
level: 1
operation: READ
primitives:
  perplexity: scripts/perplexity_search.py
---

# Web Search

Search the web and get an AI-synthesised answer with source citations.

## Usage
...
```

**pdf-save/SKILL.md:**
```yaml
---
name: pdf-save
description: Save a webpage as a PDF file with metadata.
level: 1
operation: WRITE
primitives:
  default: scripts/save_webpage_pdf.py
---

# PDF Save

Save any URL as a PDF document.

## Usage
...
```

### Step 2: Composite Skill (Level 2)

**research/SKILL.md:**
```yaml
---
name: research
description: Research a topic comprehensively with web search and optional source archival.
level: 2
operation: READ  # pdf-save only used optionally
composes:
  - web-search
  - pdf-save
---

# Research

Comprehensive topic research with source verification.

## Workflow

1. Use **web-search** to get initial answer and citations
2. Optionally fetch full content from top citations
3. If `save_sources=true`, use **pdf-save** to archive each citation

## Inputs

- `query`: The research question
- `depth`: quick | standard | thorough
- `save_sources`: boolean (default: false)

## Outputs

- `summary`: Synthesised answer
- `sources`: List of citations with key points
- `saved_pdfs`: Paths to archived PDFs (if save_sources)
```

### Step 3: Workflow Skill (Level 3)

**daily-briefing/SKILL.md:**
```yaml
---
name: daily-briefing
description: Generate comprehensive morning briefing from all sources. Run at start of day.
level: 3
operation: READ
composes:
  - email-read
  - calendar-read
  - research
  - customer-intel
---

# Daily Briefing

Generate a comprehensive morning briefing.

## Workflow

1. **Fetch calendar** → Today's meetings using calendar-read
2. **For each meeting with external attendees:**
   - Run **customer-intel** for their company
   - Run **research** for any agenda topics
3. **Check email** → Flagged/urgent items using email-read
4. **Generate briefing** → Structured summary with action items

## Decision Points

- Skip customer-intel for internal-only meetings
- Increase research depth for client presentations
- Flag urgent emails that need immediate response
```

---

## Directory Structure

Recommended organisation for composable skills:

```
skills/
├── _primitives/          # Level 0: Script references (optional)
│   ├── email.yaml
│   ├── web.yaml
│   └── ...
│
├── _atomic/              # Level 1: Atomic skills
│   ├── email-read/
│   │   └── SKILL.md
│   ├── email-draft/
│   │   └── SKILL.md
│   ├── web-search/
│   │   └── SKILL.md
│   └── ...
│
├── _composite/           # Level 2: Composite skills
│   ├── research/
│   │   └── SKILL.md
│   ├── customer-intel/
│   │   └── SKILL.md
│   └── ...
│
├── _workflows/           # Level 3: Workflow skills
│   ├── daily-synthesis/
│   │   └── SKILL.md
│   └── ...
│
└── [standalone]/         # Traditional skills (no level)
    └── SKILL.md
```

The `_` prefix directories are recommended conventions, not requirements.

---

## Validation Rules

### Composition Validation

When `composes` is specified:

1. All listed skills must exist
2. **Circular dependencies between different skills are prohibited** (e.g., A → B → A)
3. **Self-recursion is explicitly allowed** - a skill may compose itself
4. Level N skills should only compose Level < N skills (recommended)

### Why Self-Recursion is Allowed

Self-recursion - where a skill includes itself in its `composes` list - is a deliberate and powerful capability that follows established functional programming principles:

| Benefit | Description |
|---------|-------------|
| **Divide-and-conquer** | Complex problems decompose into smaller instances of the same problem |
| **Minimal code** | Recursive definitions express sophisticated algorithms concisely, reducing context consumption |
| **Dynamic parallelisation** | Each recursive invocation can spawn independent sub-agents, enabling natural parallelism |
| **Tail-call patterns** | Recursive skills can implement iterative processes efficiently |

**Example: Recursive Research Skill**

```yaml
---
name: deep-research
description: Recursively research a topic, following citations to build comprehensive understanding.
level: 3                # Level 3 because it uses recursion
operation: READ
composes:
  - deep-research       # Self-recursion for following citation chains
  - research            # Level 2 composite (not atomics directly)
---
```

This skill can research a topic, discover relevant citations, and recursively research those citations - all with a single skill definition. The recursion depth is controlled at runtime, not compile-time.

Note that `deep-research` composes `research` (Level 2), not the atomics (`web-search`, `pdf-save`) directly. This maintains proper hierarchy and MECE compliance - there's only one "research" capability at each level.

**Contrast with Circular Dependencies**

Circular dependencies between *different* skills (A → B → A) are prohibited because they:
- Create ambiguous execution order
- Prevent static analysis of the composition graph
- Indicate a design flaw (skills should compose downward, not laterally)

### Operation Propagation

For composite skills:
- If `operation` is not specified, infer from components
- If ANY component is WRITE → skill is WRITE
- If ALL components are READ → skill is READ
- TRANSFORM < READ < WRITE (safety ordering)

### Level Validation

If `level` is specified:
- Level 1: `composes` should be empty or omitted
- Level 2-3: `composes` should list at least one skill (recommended)

---

## Type System

### Why Types Matter for Skills

The composable skills architecture benefits significantly from **static type checking**, similar to strongly-typed languages like Haskell or TypeScript. Types enable:

| Benefit | Description |
|---------|-------------|
| **Composition verification** | Catch mismatched inputs/outputs at build time, not runtime |
| **Hallucination prevention** | Required inputs prevent the model from inventing facts |
| **Rigorous reasoning** | Output constraints (requires_source, requires_rationale) enforce cited, explained answers |
| **Self-documenting** | Types serve as machine-readable API documentation |
| **Better tooling** | IDE support, auto-completion, refactoring assistance |

### Input/Output Schemas

Skills can define typed inputs and outputs in their frontmatter:

```yaml
---
name: flight-search
description: Search for flights between two airports on given dates.
level: 1
operation: READ
inputs:
  - name: origin
    type: string
    required: true
    description: Origin airport code (e.g., SFO)
  - name: destination
    type: string
    required: true
    description: Destination airport code
  - name: dates
    type: DateRange
    required: true
  - name: max_stops
    type: integer
    required: false
    default: 1
outputs:
  - name: flights
    type: Flight[]
    description: Available flights sorted by price
  - name: cheapest_price
    type: number
    description: Lowest price found
---
```

### Primitive Types

The type system supports these built-in primitives:

| Type | Description | Example Values |
|------|-------------|----------------|
| `string` | Text value | "SFO", "hello world" |
| `number` | Floating-point number | 3.14, 99.99 |
| `integer` | Whole number | 1, 42, -5 |
| `boolean` | True or false | true, false |
| `date` | Calendar date | "2024-03-15" |
| `datetime` | Date with time | "2024-03-15T10:30:00Z" |
| `any` | Accepts any type | (use sparingly) |

**List types** are denoted with `[]` suffix: `string[]`, `Flight[]`

### Field Schema Properties

Each input or output field can have these properties:

```yaml
inputs:
  - name: query           # Required: field name
    type: string          # Type (primitive or custom)
    required: true        # Is this field required? (default: true)
    description: ...      # Human-readable description
    default: "default"    # Default value if not provided
```

### Epistemic Requirements (Preventing Hallucination)

Output fields can enforce **epistemic requirements** - constraints that prevent the model from hallucinating or providing unsupported claims:

```yaml
outputs:
  - name: answer
    type: string
    requires_source: true      # Must cite sources for this claim
    requires_rationale: true   # Must explain reasoning
    min_length: 50             # Minimum explanation length

  - name: sources
    type: string[]
    min_items: 2               # Must have at least 2 sources

  - name: confidence
    type: number
    range:
      - 0
      - 1                      # Constrain to [0, 1]
```

| Property | Type | Description |
|----------|------|-------------|
| `requires_source` | boolean | Output must cite supporting sources |
| `requires_rationale` | boolean | Output must include reasoning |
| `min_length` | integer | Minimum string length (for rationale) |
| `min_items` | integer | Minimum list items (for sources) |
| `range` | [min, max] | Valid range for numbers |

### Static Type Checking

The `skills-ref typecheck` command validates type compatibility across composed skills:

```bash
# Type-check all skills in a directory
skills-ref typecheck ./skills

# Verbose output showing all types
skills-ref typecheck -v ./skills/_composite ./skills/_workflows

# Type-check a specific skill
skills-ref typecheck ./skills/_workflows/trip-optimize
```

**What typecheck validates:**

1. **Input compatibility**: Parent skill's inputs can satisfy child skill's required inputs
2. **Output compatibility**: Child skill's outputs match parent's declared output types
3. **Type widening**: `integer` → `number` and `datetime` → `date` are allowed
4. **Missing dependencies**: All composed skills must be found

**Example type error:**

```
Type errors found:

  trip-optimize:
    - Type mismatch: 'trip-optimize' input 'budget' is string,
      but 'route-price' expects number
    - Composed skill 'unknown-skill' not found.
      Cannot verify type compatibility.

Found 2 type error(s) in 1 skill(s).
```

### Type Compatibility Rules

| Output Type | Compatible Input Types |
|-------------|------------------------|
| `string` | `string`, `any` |
| `integer` | `integer`, `number`, `any` |
| `number` | `number`, `any` |
| `datetime` | `datetime`, `date`, `any` |
| `date` | `date`, `any` |
| `boolean` | `boolean`, `any` |
| `any` | (any type) |
| `T[]` | `T[]`, `any[]`, `any` |

### Custom Types (Future)

Future versions will support custom type definitions:

```yaml
types:
  - name: Flight
    fields:
      airline: string
      departure: datetime
      arrival: datetime
      price: number
    description: A single flight option

  - name: DateRange
    fields:
      start: date
      end: date
```

---

## Migration Path

Existing skills don't need to change. The new fields are all optional:

1. **No changes required**: Skills without `level`/`composes`/`operation` work as before
2. **Gradual adoption**: Add fields as you refactor skills
3. **Backwards compatible**: Clients that don't understand new fields ignore them

---

## Implementation Notes

### For Skill Authors

1. **Start atomic**: Build Level 1 skills for your core operations
2. **Compose gradually**: Create Level 2 skills as patterns emerge
3. **Document workflows**: Level 3 skills need clear decision logic
4. **Explicit is better**: Always specify `composes` for clarity

### For Client Implementers

1. **Parse new fields**: Add `level`, `operation`, `composes` to your model
2. **Validate composition**: Check that composed skills exist
3. **Propagate safety**: Compute effective `operation` from components
4. **Show dependencies**: Consider displaying the composition graph

### For Discovery Systems

The composition graph enables new features:
- "Skills like X" → find skills at same level
- "Skills using X" → find composites that include a skill
- "Safe alternatives" → find READ-only versions

---

## References

- [Agent Skills Specification](specification.mdx) - Base format
- [Functional Programming Concepts](https://en.wikipedia.org/wiki/Higher-order_function) - Theoretical background
- [life-core Skills](https://github.com/edu-ap/life-core/.claude/skills) - Reference implementation

---

*This architecture extension is backwards-compatible with Agent Skills v1.0*
